        // 
        //  Copyright (c) 2008 Scott C. Klement  All rights reserved.
        //  Modernised September 2025 Nick Litten

        //  Redistribution and use in source and binary forms, with or without
        //  modification, are permitted provided that the following conditions
        //  are met:
        //  1. Redistributions of source code must retain the above copyright
        //     notice, this list of conditions and the following disclaimer.
        //  2. Redistributions in binary form must reproduce the above copyright
        //     notice, this list of conditions and the following disclaimer in the
        //     documentation and/or other materials provided with the distribution.

        //  THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
        //  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        //  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPO
        //  ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
        //  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTI
        //  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        //  OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        //  HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRI
        //  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WA
        //  OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        //  SUCH DAMAGE.
  
        /if defined(SSL_H)
        /eof
        /endif

        /define SSL_H

          // ***************************************************************
          //  The SSL Init Structure.  (All fields are for input to API)
          //   struct SSLInitStr {
          //      char *               keyringFileName;
          //      char *               keyringPassword;
          //      unsigned short int * cipherSuiteList;
          //      unsigned int         cipherSuiteListLen;
          //   };
          //   typedef struct SSLInitStr SSLInit;
          //   keyringFileName = null-terminated path to keyring file in IFS
          //   keyringPassword = null-terminated password for keyring file
          //   cipherSuiteList = pointer to cypher spec list to use during
          //          SSL handshake protocol.  You can pass *NULL if you
          //          want to use the previous SSL_Init's values.  If no
          //          no previous call, pass *NULL to use the system default.
          //   cipherSuiteListLen = number of suite entries in prev param.
          //   note that the cipherSuiteList element is a pointer to an
          //   array of unsigned shorts (i.e. 5U 0)
          // ***************************************************************
         dcl-s p_SSLInitStr pointer;
         dcl-ds SSLInitStr INZ based(p_SSLInit) align;
          SSLInit_keyri pointer;
          SSLInit_keyri pointer;
          SSLInit_ciphe pointer;
          SSLInit_ciphe zoned(0:0);
         end-ds SSLInitStr;

          // ***************************************************************
          //   struct SSLInitAppStr {
          //         char         *applicationID;
          //         unsigned int  applicationIDLen;
          //         char         *localCertificate;
          //         unsigned int  localCertificateLen;
          //         unsigned short int *cipherSuiteList;
          //         unsigned int  cipherSuiteListLen;
          //         char          reserved[28];
          //    };
          //    typedef struct SSLInitAppStr SSLInitApp;
          //    applicationID (input) ptr to null-terminated string
          //        identifying the application id value that was used
          //        to register the application for certificate use
          //        (the QSYRGAP or QsyRegisterAppForCertUse API)
          //    applicationIDLen (input) Length of string (above)
          //    localCertificate (i/o) area of memory to place the registered
          //        local certificate.  (must be allocated by the calling
          //        app, and the size of the area given in localCertificateLen)
          //        Most certs are less than 2k in len.  If cert is not to be
          //        returned, *NULL can be passed.
          //    localCertificateLen (i/o) length of area of memory allocated
          //        to localCertificate on input, and length of actual
          //        certificate on output.  If no cert is to be returned,
          //        this should be set to 0.
          //    cipherSuiteList & cipherSuiteListLen are the same as they
          //       are in the SSLInitStr struct above, except that if you
          //       pass NULL, the system will use the values from SSL_Init.
          //    reserved1 must be all x'00'
          // ***************************************************************
         dcl-ds SSLInitAppStr INZ based(p_SSLInitApp) align;
          SSLInitApp_a pointer;
          SSLInitApp_a uns(0);
          SSLInitApp_l pointer;
          SSLInitApp_loca uns(0);
          SSLInitApp_ciph pointer EXTFLD;
          SSLInitApp_ciph uns(0) EXTFLD;
          SSLInitApp_rese char(28);
         end-ds SSLInitAppStr;

          // ***************************************************************
          //   The SSLHandle structure is returned by the SSL_Create API
          //   struct SSLHandleStr {
          //      int            fd;
          //      int            createFlags;
          //      unsigned       protocol;
          //      unsigned       timeout;
          //      unsigned char  cipherKind[3];
          //      unsigned short int cipherSuite;
          //      unsigned short int* cipherSuiteList;
          //      unsigned int        cipherSuiteListLen;
          //      unsigned char* peerCert;
          //      unsigned       peerCertLen;
          //      int            peerCertValidateRc;
          //      int            (*exitPgm)(struct SSLHandleStr* sslh);
          //   };
          // ***************************************************************
         dcl-s p_SSLHandle pointer;
         dcl-ds SSLHandleStr INZ based(p_SSLHandle);
          SSLHandle_fd int(10);
          SSLHandle_creat int(10) EXTFLD;
          SSLHandle_proto uns(10);
          SSLHandle_timeo uns(10);
          SSLHandle_ciphe char(3);
          SSLHandle_ciphe uns(5);
          SSLHandle_ciphe pointer;
          SSLHandle_ciphe uns(0);
          SSLHandle_peerC pointer EXTFLD;
          SSLHandle_peerC uns(10) EXTFLD;
          SSLHandle_peerC int(0) EXTFLD;
          SSLHandle_exitP pointer procptr;
         end-ds SSLHandleStr;

          // ***************************************************************
          //  Flags for the SSL_Create() proc
          // ***************************************************************
         dcl-c SSL_ENCRYPT 1;
         dcl-c SSL_DONT_ENCRYP 0;

          // ***************************************************************
          //  Error numbers that can be returned by the SSL_xxxx procs.
          //    (Note that some of these, such as SSL_ERROR_IO, merely
          //     mean that you need to check errno)
          // ***************************************************************
         dcl-c SSL_ERROR_NO_CIPHERS -1;
         dcl-c SSL_ERROR_NO_CERTIFICATE -2;
         dcl-c SSL_ERROR_BAD_CERTIFICATE -4;
         dcl-c SSL_ERROR_UNSUPPORTED_CERTIFICATE_TYPE -6;
         dcl-c SSL_ERROR_IO -10;
         dcl-c SSL_ERROR_BAD_MESSAGE -11;
         dcl-c SSL_ERROR_BAD_MAC -12;
         dcl-c SSL_ERROR_UNSUPPORTED -13;
         dcl-c SSL_ERROR_BAD_CERT_SIG -14;
         dcl-c SSL_ERROR_BAD_CERT -15;
         dcl-c SSL_ERROR_BAD_PEER -16;
         dcl-c SSL_ERROR_PERMISSION_DENIED -17;
         dcl-c SSL_ERROR_SELF_SIGNED -18;
         dcl-c SSL_ERROR_BAD_MALLOC -20;
         dcl-c SSL_ERROR_BAD_STATE -21;
         dcl-c SSL_ERROR_SOCKET_CLOSED -22;
         dcl-c SSL_ERROR_NOT_TRUSTED_ROOT -23;
         dcl-c SSL_ERROR_CERT_EXPIRED -24;
         dcl-c SSL_ERROR_BAD_DATE -25;
         dcl-c SSL_ERROR_BAD_KEY_LEN_FOR_EXPORT -26;
         dcl-c SSL_ERROR_NOT_KEYRING -90;
         dcl-c SSL_ERROR_KEYPASSWORD_EXPIRED -91;
         dcl-c SSL_ERROR_CERTIFICATE_REJECTED -92;
         dcl-c SSL_ERROR_SSL_NOT_AVAILABLE -93;
         dcl-c SSL_ERROR_NO_INIT -94;
         dcl-c SSL_ERROR_NO_KEYRING -95;
         dcl-c SSL_ERROR_NOT_ENABLED -96;
         dcl-c SSL_ERROR_BAD_CIPHER_SUITE -97;
         dcl-c SSL_ERROR_CLOSED -98;
         dcl-c SSL_ERROR_UNKNOWN -99;
         dcl-c SSL_ERROR_NOT_REGISTERED -1009;

          // ***************************************************************
          //   The following cipher suites work when using a version 3.0
          //   to version 3.0 SSL implementation
          // ***************************************************************
         dcl-c SSL_RSA_WITH_NULL_MD5 1;
         dcl-c SSL_RSA_WITH_NULL_SHA 2;
         dcl-c SSL_RSA_WITH_RC4_128_SHA 5;
         dcl-c SSL_RSA_WITH_DES_CBC_SHA 9;
         dcl-c SSL_RSA_WITH_3DES_EDE_CBC_SHA 10;

          // ***************************************************************
          //   The following cipher suites work when using a version 2.0
          //   to version 2.0 SSL implementation as well as version 3.0
          //   to version 3.0...
          // ***************************************************************
         dcl-c SSL_RSA_EXPORT_WITH_RC4_40_MD5 3;
         dcl-c SSL_RSA_WITH_RC4_128_MD5 4;
         dcl-c SSL_RSA_EXPORT_WITH_RC2_CBC_40_MD5 6;

          // ***************************************************************
          //   The following cipher suites work when using a version 2.0
          //   to version 2.0 SSL implementation
          // ***************************************************************
         dcl-c SSL_RSA_WITH_RC2_CBC_128_MD5 65281;
         dcl-c SSL_RSA_WITH_DES_CBC_MD5 65282;
         dcl-c SSL_RSA_WITH_3DES_EDE_CBC_MD5 65283;

          // ***************************************************************
          //   values for "how" parm of SSL_Handshake
          // ***************************************************************
         dcl-c SSL_HANDSHAKE_AS_CLIENT 0;
         dcl-c SSL_HANDSHAKE_AS_SERVER 1;
         dcl-c SSL_HANDSHAKE_AS_SERVER_WITH_CLIENT_AUTH 2;
         dcl-c SSL_HANDSHAKE_AS_SERVER_WITH_OPTIONAL_CLIENT_AUTH 3;

          // ***************************************************************
          //   Initialize the current job for SSL
          //   int SSL_Init(SSLInit *init);
          //   The SSL_Init function is used to establish the SSL security
          //   information to be used for all SSL sessions for the current
          //   job.
          // ***************************************************************
         dcl-pr SSL_Init int(10) ExtProc('SSL_Init');
         init pointer value;
         end-pr SSL_Init;

          // ***************************************************************
          //   Initialize the Current Job for SSL processing Based on the
          //    Application Identifier
          //  int SSL_Init_Application(SSLInitApp *init_app);
          //  Uses the application identifier to determine and then
          //  establish the certificate for use by the SSL handshake
          //  protocol processing.
          // ***************************************************************
         dcl-pr SSL_Init_Application int(10) ExtProc('SSL_Init_Application');
         init_app pointer value;
         end-pr SSL_Init_Application;

          // ***************************************************************
          //  SSL_Create() -- enable SSL support on a given socket descr.
          //    SSLHandle *SSL_Create(int socket_descriptor, int flags);
          // ***************************************************************
         dcl-pr SSL_Create pointer ExtProc('SSL_Create');
         Sock_desc zoned(0:VA) ue;
         flags int(10) value;
         end-pr SSL_Create;

          // ***************************************************************
          //  Initiate the SSL Handshake protool
          //   int SSL_Handshake(SSLHandle *handle, int how);
          //   The SSL_Handshake() function is used by a program to initiate
          //   the SSL handshake protocol.  Both the client and the server
          //   program must call the SSL_Handshake verb in order to initiate
          //   handshake processing.
          // ***************************************************************
         dcl-pr SSL_Handshake int(10) ExtProc('SSL_Handshake');
          handle pointer value;
          how int(10) value;
         end-pr SSL_Handshake;

          // ***************************************************************
          //  Read data from SSL-enabled socket
          //   int SSL_Read(SSLHandle *handle, void *buffer, int buflen);
          //   handle = handle returned by SSL_Create
          //   buffer = place where the data is :)
          //   buflen = size of buffer (max size to read at once)
          //  returns length of data read, or an error upon failure
          // ***************************************************************
         dcl-pr SSL_Read int(10) ExtProc('SSL_Read');
          handle pointer value;
          buffer pointer value;
          buflen int(10) value;
         end-pr SSL_Read;

          // ***************************************************************
          //  Write data to SSL-enabled socket
          //   int SSL_Write(SSLHandle *handle, void *buffer, int buflen);
          //   handle = handle returned by SSL_Create
          //   buffer = place where the data is :)
          //   buflen = size of buffer (amount of data to write)
          //  returns length of data written, or an error upon failure
          // ***************************************************************
         dcl-pr SSL_Write int(10) ExtProc('SSL_Write');
          handle pointer value;
          buffer pointer value;
          buflen int(10) value;
         end-pr SSL_Write;

          // ***************************************************************
          //   End SSL support for a given SSL-enabled socket.
          //    handle = SSL session to end.
          // ***************************************************************
         dcl-pr SSL_Destroy  ExtProc('SSL_Destroy');
          handle pointer value;
         end-pr SSL_Destroy;
